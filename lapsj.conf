#!/bin/bash
#---------------------------------------------------------------------------
# lapsj - madman's Linux, Apache, PostgreSQL, Samba, & Java Box
#
# - see lapsj.env file to customize sensitive data
#---------------------------------------------------------------------------

# configuration filenames
CONFIG_NAME="lapsj"
CONFIG_MAIN_FILE="${CONFIG_NAME}.conf"
CONFIG_ENV_FILE="${CONFIG_NAME}.env"

# short name describing locally installed software
# (non apt-get stuff)
PKG_NAME=mvm

# group to run locally installed software
# and system non-login user to run it
PKG_GROUP="${PKG_NAME}admin"
PKG_ROOT_USER="${PKG_NAME}root"

# group and user to access Samba shares
SAMBA_GROUP="${PKG_NAME}share"
SAMBA_USER="${PKG_NAME}assist"

# locations to install & configure locally software
# (everything else should be OS default)
PKG_DIR_CONFIG="/etc/opt/${PKG_NAME}"
PKG_DIR_EXEC="/opt/${PKG_NAME}"
PKG_DIR_DATA="/var/opt/${PKG_NAME}"
PKG_DIR_BACKUPS="${PKG_DIR_DATA}/backups"
PKG_DIR_RESTORE="${PKG_DIR_DATA}/restore"

EASYRSA_DIR="${PKG_DIR_DATA}/easy-rsa"
APACHE_DIR="${PKG_DIR_DATA}/html"
PUBLIC_HTML="${APACHE_DIR}/public"
PRIVATE_HTML="${APACHE_DIR}/private"

# verify sensitive var's file exists
if [ ! -f "${CONFIG_ENV_FILE}" ]
then
    get_config_file_from_repo_and_exit ${CONFIG_ENV_FILE}
fi

# verify sensitive var's file is private
curr_permissions=$(stat -c "%a" "${CONFIG_ENV_FILE}")
if [ "$curr_permissions" != "600" ]
then
    echo "ERROR: ${CONFIG_ENV_FILE} access permissions must be '600'"
    exit 1
fi

# load in sensitive var's file
source ${CONFIG_ENV_FILE}
echo ".. sensitive variables loaded for box"

# Box customization script
configure_box () {
    setup_network
    add_admin_group_and_system_user
    create_system_folders
    install_and_configure_samba_shares
    install_and_configure_ca
    install_and_configure_web_server
}

setup_network () {
    setup_network_interface
    setup_hostname
}

setup_network_interface () {
    if [ "${IFACE}" != "static" ]
    then
        return
    fi

    local interfaces_path="/etc/network/interfaces"
    backup_or_recover_original_file $interfaces_path
    local resolv_path="/etc/resolv.conf"
    backup_or_recover_original_file $resolv_path

    # get line num primary network interface
    local line_to_replace=$(grep -En '\Wdhcp$' $interfaces_path | cut -d: -f1)

    # build its replacement
    head -${line_to_replace} $interfaces_path > interfaces.temp
    sed -i 's/dhcp/static/' interfaces.temp
    echo " address ${IFACE_ADDRESS}" >> interfaces.temp
    echo " netmask ${IFACE_NETMASK}" >> interfaces.temp
    echo " broadcast ${IFACE_BROADCAST}" >> interfaces.temp
    echo " gateway ${IFACE_GATEWAY}" >> interfaces.temp

    # update name servers
    if [ ! -z "${NAMESERVER_1}" ]
    then
        echo "nameserver ${NAMESERVER_1}" > $resolv_path
        if [ ! -z "${NAMESERVER_2}" ]
        then
            echo "nameserver ${NAMESERVER_2}" >> $resolv_path
        fi
    fi

    # change the primary interface
    mv interfaces.temp $interfaces_path

    echo ".. changed network interfaces"
    cat $interfaces_path

    echo ".. restarting network"
    systemctl restart networking
    sleep 2
}

setup_hostname () {
    echo ".. setting hostname with system"
    hostnamectl set-hostname $HOSTNAME

    echo ".. updating hosts file"
    local hosts_path="/etc/hosts"
    local ip_address="${IFACE_ADDRESS}"
    if [ -z "${ip_address}" ]
    then
        ip_address=$(get_ip_address)
    fi

    backup_or_recover_original_file $hosts_path
    echo "127.0.0.1 localhost" > $hosts_path
    echo "${ip_address} ${FQDN} ${HOSTNAME}" >> $hosts_path
    cat $hosts_path

    echo ".. hostname changed"
    hostnamectl
}

get_ip_address () {
    local iface_name=$(ip route get 1.1.1.1 | grep -o "dev [^ ]*" | awk '{print $2}')
    ip -4 addr show $iface_name | grep -oP '(?<=inet\s)\d+(\.\d+){3}'
}

restart_network () {
    echo ".. setting hostname"
    hostnamectl set-hostname ${HOSTNAME}
}

add_admin_group_and_system_user () {
    if [ ! $(getent group $PKG_GROUP) ]
    then
        groupadd -r $PKG_GROUP
    fi
    echo ".. group (${PKG_GROUP}) added to support appliance admin functions"

    if [ ! $(getent passwd $PKG_ROOT_USER) ]
    then
        useradd -r $PKG_ROOT_USER -g $PKG_GROUP
    fi
    echo ".. system user (${PKG_ROOT_USER}) added to execute appliance jobs"
}

create_system_folders () {
    echo ".. creating system folders"
    create_dir_and_set_owner $PKG_DIR_CONFIG $PKG_ROOT_USER $PKG_GROUP
    create_dir_and_set_owner $PKG_DIR_EXEC $PKG_ROOT_USER $PKG_GROUP
    create_dir_and_set_owner $PKG_DIR_DATA $PKG_ROOT_USER $PKG_GROUP
    create_dir_and_set_owner $PKG_DIR_BACKUPS $PKG_ROOT_USER $PKG_GROUP
    create_dir_and_set_owner $PKG_DIR_RESTORE $PKG_ROOT_USER $PKG_GROUP
}

# $1: path
# $2: owner (optional)
# $3: group (optional, requires owner)
create_dir_and_set_owner()
{
    mkdir -p $1
    rm -rf $1/*
    echo ".. created directory ($1)"

    if [ -z "$2" ] || [ -z "$3" ]
    then
        return # no owner & group
    fi

    chown -R $2:$3 $1
    echo ".. set owner and group ($2:$3)"
}

install_and_configure_samba_shares()
{
    echo ".. installing samba"
    apt-get -y install samba smbclient

    if [ ! $(getent group $SAMBA_GROUP) ]
    then
        groupadd -r $SAMBA_GROUP
    fi
    echo ".. group (${SAMBA_GROUP}) added to support Samba file shares"

    echo ".. set group for Samba file shares"
    chgrp -vR $SAMBA_GROUP $PKG_DIR_BACKUPS
    chgrp -vR $SAMBA_GROUP $PKG_DIR_RESTORE

    echo ".. set file access permissions for Samba file shares"
    chmod -v 775 $PKG_DIR_BACKUPS
    chmod -v 775 $PKG_DIR_RESTORE

    if [ ! $(getent passwd $SAMBA_USER) ]
    then
        useradd -r $SAMBA_USER -g $SAMBA_GROUP
    fi
    echo ".. system user (${SAMBA_USER}) added to support Samba user with same name"

    echo "$SAMBA_USER:$SAMBA_PASSWORD" | chpasswd
    echo ".. system password set"
    (echo "$SAMBA_PASSWORD" ; echo "$SAMBA_PASSWORD") | smbpasswd -s -a $SAMBA_USER
    echo ".. Samba password set"

    echo ".. configuring Samba"
    local config_file="/etc/samba/smb.conf"
    backup_or_recover_original_file $config_file
    cat <<EOT >$config_file
[mvm-backups]
    comment = Home of VM's daily backups
    path = $PKG_DIR_BACKUPS
    read only = yes
    browseable = yes

[mvm-restore]
    comment = Staging area for restoring a backup
    path = $PKG_DIR_RESTORE
    read only = no
    browseable = yes
EOT
    systemctl restart smbd
    echo ".. Samba configuration completed"
}

install_and_configure_ca()
{
    echo ".. installing easy-rsa"
    apt-get -y install easy-rsa

    echo ".. create home for CA in file system"
    create_dir_and_set_owner $EASYRSA_DIR $PKG_ROOT_USER $PKG_GROUP

    echo ".. set file access permissions for CA"
    chmod -v 770 $EASYRSA_DIR

    echo ".. create links to easy-rsa scripts in OS"
    su -c "ln -vs /usr/share/easy-rsa/* ${EASYRSA_DIR}/" $PKG_ROOT_USER 

    echo ".. configuring CA settings"
    cat <<EOT >${EASYRSA_DIR}/vars
set var EASYRSA_REQ_COUNTRY     "${EASYRSA_REQ_COUNTRY}"
set var EASYRSA_REQ_PROVINCE    "${EASYRSA_REQ_PROVINCE}"
set var EASYRSA_REQ_CITY        "${EASYRSA_REQ_CITY}"
set var EASYRSA_REQ_ORG         "${EASYRSA_REQ_ORG}"
set var EASYRSA_REQ_EMAIL       "${EASYRSA_REQ_EMAIL}"
set var EASYRSA_REQ_OU          "${EASYRSA_REQ_OU}"
EOT
    chown $PKG_ROOT_USER:$PKG_GROUP $EASYRSA_DIR/vars
    chmod 600 $EASYRSA_DIR/vars

    echo ".. create public key infrastructure (PKI)"
    cd $EASYRSA_DIR
    su -c "./easyrsa init-pki" $PKG_ROOT_USER
    mv vars pki/

    echo ".. create CA key pair"
    su -c "EASYRSA_REQ_CN=${FQDN} ./easyrsa --batch build-ca nopass" $PKG_ROOT_USER

    echo ".. CA created"
    su -c "./easyrsa show-ca" $PKG_ROOT_USER

    echo ".. create server's key pair"
    su -c "./easyrsa --batch build-server-full ${FQDN} nopass" $PKG_ROOT_USER
}

install_and_configure_web_server()
{
    echo ".. installing apache web server"
    apt-get -y install apache2

    echo ".. create apache data directories (html)"
    create_dir_and_set_owner $APACHE_DIR $PKG_ROOT_USER $PKG_GROUP
    create_dir_and_set_owner $PUBLIC_HTML $PKG_ROOT_USER $PKG_GROUP
    chmod -R 755 $PUBLIC_HTML
    create_dir_and_set_owner $PRIVATE_HTML $PKG_ROOT_USER $PKG_GROUP
    chmod -R 755 $PRIVATE_HTML

    echo ".. updating ports configuration"
    local ports_config="/etc/apache2/ports.conf"
    backup_or_recover_original_file $ports_config
    sed -i "/^Listen 80$/a\Listen ${ADDITIONAL_HTTP_PORT}" $ports_config
    sed -i "/\tListen 443/a\\\tListen ${ADDITIONAL_HTTPS_PORT}" $ports_config
    cat $ports_config

    echo ".. building HTTP host configuration"
    local http_host_config="/etc/apache2/sites-available/${PKG_NAME}-http.conf"
    cat <<EOT >$http_host_config
<VirtualHost *:80 *:${ADDITIONAL_HTTP_PORT}>
    ServerAdmin ${PUBLIC_ADMIN_EMAIL}
    DocumentRoot ${PUBLIC_HTML}

    # LogLevel debug
    ErrorLog \${APACHE_LOG_DIR}/error.log
    CustomLog \${APACHE_LOG_DIR}/access.log combined

    <Directory "${PUBLIC_HTML}">
        AllowOverride None
        Options Indexes FollowSymLinks
        Require all granted
    </Directory>
</VirtualHost>
EOT
    cp /var/www/html/index.html $PUBLIC_HTML

    echo ".. building HTTPS host configuration"
    local https_host_config="/etc/apache2/sites-available/${PKG_NAME}-https.conf"
    cat <<EOT >$https_host_config
<VirtualHost *:443 *:${ADDITIONAL_HTTPS_PORT}>
    ServerAdmin ${PUBLIC_ADMIN_EMAIL}
    DocumentRoot ${PUBLIC_HTML}

    # LogLevel debug
    ErrorLog \${APACHE_LOG_DIR}/error.log
    CustomLog \${APACHE_LOG_DIR}/access.log combined

    SSLEngine               on
    SSLCertificateFile      ${EASYRSA_DIR}/pki/issued/${FQDN}.crt
    SSLCertificateKeyFile   ${EASYRSA_DIR}/pki/private/${FQDN}.key

    <Directory "${PUBLIC_HTML}">
        AllowOverride None
        Options Indexes FollowSymLinks
        Require all granted
    </Directory>

</VirtualHost>
EOT
    cp /var/www/html/index.html $PRIVATE_HTML

    a2dissite 000-default.conf
    a2ensite $(basename $http_host_config)
    a2enmod ssl
    a2ensite $(basename $https_host_config)

    systemctl restart apache2
    echo ".. web server configuration completed"
}
